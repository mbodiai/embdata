
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.29">
    
    
      
        <title></title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.76a95c52.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="stylesheets/extra.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#embodied-data-experimental" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="" class="md-header__button md-logo" aria-label="" data-md-component="logo">
      
  <img src="assets/images/mbodi.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              embodied data (Experimental)
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="red"  aria-hidden="true"  type="radio" name="__palette" id="__palette_0">
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="" class="md-nav__button md-logo" aria-label="" data-md-component="logo">
      
  <img src="assets/images/mbodi.png" alt="logo">

    </a>
    
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Usage
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#sample" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sample
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#mobilesinglehandcontrol" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mobile Single Hand Control
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#humanoidcontrol" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Humanoid Control
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#subclassing-motion" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Subclassing Motion
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#image" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Image
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#trajectory" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Trajectory
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#episode" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Episode
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#pose6d" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pose 6D
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="#handcontrol" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Hand Control
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#table-of-contents" class="md-nav__link">
    <span class="md-ellipsis">
      Table of Contents
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#installation" class="md-nav__link">
    <span class="md-ellipsis">
      Installation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quick-examples" class="md-nav__link">
    <span class="md-ellipsis">
      Quick Examples
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Quick Examples">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#episode" class="md-nav__link">
    <span class="md-ellipsis">
      Episode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geometry" class="md-nav__link">
    <span class="md-ellipsis">
      Geometry
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#usage" class="md-nav__link">
    <span class="md-ellipsis">
      Usage
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#license" class="md-nav__link">
    <span class="md-ellipsis">
      License
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#design-decisions" class="md-nav__link">
    <span class="md-ellipsis">
      Design Decisions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    <span class="md-ellipsis">
      Classes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#data-manupulation" class="md-nav__link">
    <span class="md-ellipsis">
      Data Manupulation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rl-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      RL Definitions
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="embodied-data-experimental">embodied data (Experimental)</h1>
<p>Visualize, transform, clean, any type of unstructured multimodal data instantly.</p>
<div class="badge-box"> 
<img src="https://img.shields.io/pypi/v/embdata.svg" class="badge">
<img src="https://img.shields.io/pypi/pyversions/embdata.svg" class="badge">
</div>

<hr>

<p>This library enables the vast majority of data processing, visualization, and analysis to be done in a single line of code with minimal dependencies. It is designed to be used in conjunction with <a href="https://rerun.io">rerun.io</a> for visualizing complex data structures and trajectories and <a href="https://github.com/huggingface/lerobot">LeRobot</a> for robotics simulations and training. See <a href="https://github.com/mbodiai/embodied-agents">embodied-agents</a> for real-world usage.</p>
<p><a href="https://www.youtube.com/watch?v=L5JqM2_rIRM"><img alt="Video" src="https://camo.githubusercontent.com/b168669456a353f70d7529f73189caaa82c4c54365e4e2276cb9b206f4aef189/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f4c354a714d325f7249524d2f302e6a7067" /></a></p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#embodied-data-experimental">embodied data (Experimental)</a><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#quick-examples">Quick Examples</a><ul>
<li><a href="#episode">Episode</a></li>
<li><a href="#geometry">Geometry</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a></li>
<li><a href="#license">License</a></li>
<li><a href="#design-decisions">Design Decisions</a></li>
<li><a href="#classes">Classes</a><ul>
<li><a href="#episode-1">Episode</a></li>
<li><a href="#image">Image</a></li>
<li><a href="#sample">Sample</a></li>
<li><a href="#trajectory">Trajectory</a></li>
<li><a href="#motion">Motion</a><ul>
<li><a href="#key-concepts">Key Concepts</a></li>
</ul>
</li>
<li><a href="#anymotioncontrol">AnyMotionControl</a></li>
<li><a href="#handcontrol">HandControl</a></li>
<li><a href="#absolutehandcontrol">AbsoluteHandControl</a></li>
<li><a href="#relativeposehandcontrol">RelativePoseHandControl</a></li>
<li><a href="#headcontrol">HeadControl</a></li>
<li><a href="#mobilesinglehandcontrol">MobileSingleHandControl</a></li>
<li><a href="#mobilebimanualarmcontrol">MobileBimanualArmControl</a></li>
<li><a href="#humanoidcontrol">HumanoidControl</a></li>
</ul>
</li>
<li><a href="#data-manipulation-definitions">Data Manipulation Definitions</a></li>
<li><a href="#rl-definitions">RL Definitions</a></li>
</ul>
</li>
</ul>
<h2 id="installation">Installation</h2>
<div class="codehilite"><pre><span></span><code>pip install embdata
</code></pre></div>

<p>Optionally, clone lerobot <a href="https://github.com/huggingface/lerobot">(https://github.com/huggingface/lerobot)</a> and install:</p>
<div class="codehilite"><pre><span></span><code>git clone https://github.com/mbodiai/lerobot # or use our fork to install all dependencies at once.
cd lerobot
pip install -e .
</code></pre></div>

<h2 id="quick-examples">Quick Examples</h2>
<p>Hover with intellisense or view the table of contents to see documentation for each class and method.</p>
<ul>
<li>The <code><strong>Episode</strong></code> class provides a list-like interface for a sequence of observations, actions, and/or other data. It's designed to streamline exploratory data analysis and manipulation of time series data.</li>
<li>The <code>trajectory</code> method extracts a trajectory from the episode for a specified field, and enables easy visualization and analysis of the data, resampling with different frequencies, and filtering operations, and rescaling/normalizing the data.</li>
<li>The <code>show</code> method visualizes the episode with rerun.io, a platform for visualizing 3D geometrical data, images, and graphs.</li>
<li>The <code><strong>Sample</strong></code> class is a dict-like interface for serializing, recording, and manipulating arbitrary data. It provides methods for flattening and unflattening nested structures, converting between different formats, and integrating with machine learning frameworks and gym spaces.</li>
</ul>

<h3 id="episode">Episode</h3>
<div class="codehilite"><pre><span></span><code>from embdata import Episode, TimeStep, ImageTask, Image, Motion, VisionMotorEpisode
from embdata.geometry import Pose6D
from embdata.motion.control import MobileSingleHandControl, HandControl, HeadControl
from datasets import get_dataset_config_info, get_dataset_config_names, load_dataset
from embdata.describe import describe
from embdata.episode import Episode, VisionMotorEpisode
from embdata.sample import Sample

# Method 1: Create an episode from a HuggingFace dataset
ds = load_dataset(&quot;mbodiai/oxe_bridge_v2&quot;, split=&quot;train&quot;).take(10)
describe(ds)
ds = Sample(ds)
obs, actions, states = ds.flatten(to=&quot;observation&quot;), ds.flatten(to=&quot;action&quot;), ds.flatten(to=&quot;state&quot;)
zipped = zip(obs, actions, states, strict=False)
episode = VisionMotorEpisode(steps=zipped, freq_hz=5, observation_key=&quot;observation&quot;, action_key=&quot;action&quot;, state_key=&quot;state&quot;)
episode.show(mode=&quot;local&quot;) # Visualize the episode with rerun.io

# Method 2: Create an episode from separate lists of observations, actions, and states
observations = [{&quot;image&quot;: ..., &quot;task&quot;: &quot;task1&quot;, &quot;depth&quot;: ...},
                {&quot;image&quot;: ..., &quot;task&quot;: &quot;task2&quot;},
                {&quot;image&quot;: , &quot;task&quot;: &quot;task2&quot;}]
actions = [Motion(position=[0.1, 0.2, 0.3], orientation=[0, 0, 0, 1]),
           BimanualArmControl(joint_angles=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6], ...)]
           AnyMotionControl(velocity=0.1, joint_angles=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6])]
states = [{&quot;scene_objects&quot;: ..., &quot;reward&quot;: 0},
          {&quot;scene_objects&quot;: ..., &quot;reward&quot;: 1}]
episode2 = Episode(zip(observations, actions, states))


# Method 3: Create an episode from a single list of dicts of any structure
steps = [
    {&quot;observation&quot;: {&quot;image&quot;: np.random.rand(224, 224, 3), &quot;task&quot;: &quot;pick&quot;},
     &quot;action&quot;: {&quot;position&quot;: [0.1, 0.2, 0.3], &quot;orientation&quot;: [0, 0, 0, 1]}},
    {&quot;observation&quot;: {&quot;image&quot;: np.random.rand(224, 224, 3), &quot;task&quot;: &quot;place&quot;},
     &quot;action&quot;: {&quot;position&quot;: [0.4, 0.5, 0.6], &quot;orientation&quot;: [0, 1, 0, 0]}}
]
episode3 = Episode(steps)

# Convert to LeRobot dataset
lerobot_dataset = episode1.lerobot()

# Convert from LeRobot dataset back to Episode
episode_from_lerobot = Episode.from_lerobot(lerobot_dataset)

# Visualize the episode with rerun
episode1.show(mode=&quot;local&quot;)
# Iterate over steps
for step in episode.iter():
    print(f&quot;Task: {step.observation.task}, Action: {step.action.position}&quot;)

# Extract trajectory
action_trajectory = episode.trajectory(field=&quot;action&quot;, freq_hz=10)

# Visualize episode
episode.show(mode=&quot;local&quot;)
</code></pre></div>

<h3 id="geometry">Geometry</h3>
<div class="codehilite"><pre><span></span><code>from embdata.geometry import Pose6D
import numpy as np

# Create a 6D pose
pose = Pose6D(x=1.0, y=2.0, z=3.0, roll=0.1, pitch=0.2, yaw=0.3)

# Convert to different units
pose_cm = pose.to(&quot;cm&quot;)
pose_deg = pose.to(angular_unit=&quot;deg&quot;)

# Get quaternion representation
quat = pose.to(&quot;quaternion&quot;)

# Get rotation matrix
rot_matrix = pose.to(&quot;rotation_matrix&quot;)
</code></pre></div>

<h2 id="usage">Usage</h2>
<details id="sample">
<summary>Sample</summary>

<p>The <code>Sample</code> class is a flexible base model for serializing, recording, and manipulating arbitrary data.</p>

<p><strong>Key features</strong></p>

<ul>
<li>Serialization and deserialization of complex data structures</li>
<li>Flattening and unflattening of nested structures</li>
<li>Conversion between different formats (e.g., dict, numpy arrays, torch tensors)</li>
<li>Integration with machine learning frameworks and gym spaces</li>
</ul>

<p><strong>Usage example</strong></p>

<pre><code>from embdata import Sample

# Create a simple Sample
sample = Sample(x=1, y=2, z={"a": 3, "b": 4})

# Flatten the sample
flat_sample = sample.flatten()
print(flat_sample)  # [1, 2, 3, 4]

# Flatten to a nested field
nested_sample = Sample(x=1, y=2, z=[{"a": 3, "b": 4}, {"a": 5, "b": 6}])
a_fields = nested_sample.flatten(to="a")  # [3, 5]

# Convert to different formats
as_dict = sample.to("dict")
as_numpy = sample.numpy()
as_torch = sample.torch()

# Create a random sample based on the structure
random_sample = sample.random_sample()

# Get the corresponding Gym space
space = sample.space()

# Read a Sample from JSON or dictionary
sample_from_json = Sample.read('{"x": 1, "y": 2}')

# Get default value and space
default_sample = Sample.default_value()
default_space = Sample.default_space()

# Get model information
model_info = sample.model_info()

# Pack and unpack samples
samples = [Sample(a=1, b=2), Sample(a=3, b=4)]
packed = Sample.pack_from(samples)
unpacked = packed.unpack()

# Convert to HuggingFace Dataset and Features
dataset = sample.dataset()
features = sample.features()
</code></pre>

<p><strong>Methods</strong></p>

<ul>
<li><code>flatten()</code>: Flattens the nested structure into a 1D representation</li>
<li><code>unflatten()</code>: Reconstructs the original nested structure from a flattened representation</li>
<li><code>to(format)</code>: Converts the sample to different formats (dict, numpy, torch, etc.)</li>
<li><code>random_sample()</code>: Creates a random sample based on the current structure</li>
<li><code>space()</code>: Returns the corresponding Gym space for the sample</li>
<li><code>read()</code>: Reads a Sample instance from a JSON string, dictionary, or path</li>
<li><code>default_value()</code>: Gets the default value for the Sample instance</li>
<li><code>default_space()</code>: Returns the Gym space for the Sample class based on its class attributes</li>
<li><code>model_info()</code>: Gets the model information</li>
<li><code>unpack_from()</code>: Packs a list of samples into a single sample with lists for attributes</li>
<li><code>pack_from()</code>: Unpacks the packed Sample object into a list of Sample objects or dictionaries</li>
<li><code>dataset()</code>: Converts the Sample instance to a HuggingFace Dataset object</li>
<li><code>features()</code>: Converts the Sample instance to a HuggingFace Features object</li>
<li><code>lerobot()</code>: Converts the Sample instance to a LeRobot dataset</li>
<li><code>space_for()</code>: Default Gym space generation for a given value</li>
<li><code>init_from()</code>: Initializes a Sample instance from various data types</li>
<li><code>from_space()</code>: Generates a Sample instance from a Gym space</li>
<li><code>field_info()</code>: Gets the extra json values set from a FieldInfo for a given attribute key</li>
<li><code>default_sample()</code>: Generates a default Sample instance from its class attributes</li>
<li><code>numpy()</code>: Converts the Sample instance to a numpy array</li>
<li><code>tolist()</code>: Converts the Sample instance to a list</li>
<li><code>torch()</code>: Converts the Sample instance to a PyTorch tensor</li>
<li><code>json()</code>: Converts the Sample instance to a JSON string</li>
</ul>

<p>The <code>Sample</code> class provides a wide range of functionality for data manipulation, conversion, and integration with various libraries and frameworks.</p>

</details>

<details id="mobilesinglehandcontrol">
<summary>MobileSingleHandControl</summary>
<p>The <code class ="back-text">MobileSingleHandControl</code> class represents control for a robot that can move its base in 2D space with a 6D EEF control and grasp.</p>

<p><strong>Usage Example</strong></p>
<pre><code>from embdata.geometry import PlanarPose
from embdata.motion.control import MobileSingleHandControl, HandControl, HeadControl

# Create a MobileSingleHandControl instance
control = MobileSingleHandControl(
    base=PlanarPose(x=1.0, y=2.0, theta=0.5),
    hand=HandControl(
        pose=Pose(position=[0.1, 0.2, 0.3], orientation=[0, 0, 0, 1]),
        grasp=0.5
    ),
    head=HeadControl(tilt=-0.1, pan=0.2)
)

# Access and modify the control
print(control.base.x)  # Output: 1.0
control.hand.grasp = 0.8
print(control.hand.grasp)  # Output: 0.8
</code></pre>
</details>

<details id="humanoidcontrol">
<summary>HumanoidControl</summary>
<p>The <code class ="back-text">HumanoidControl</code> class represents control for a humanoid robot.</p>

<p><strong>Usage Example</strong></p>
<pre><code>import numpy as np
from embdata.motion.control import HumanoidControl, HeadControl

# Create a HumanoidControl instance
control = HumanoidControl(
    left_arm=np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6]),
    right_arm=np.array([0.2, 0.3, 0.4, 0.5, 0.6, 0.7]),
    left_leg=np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6]),
    right_leg=np.array([0.2, 0.3, 0.4, 0.5, 0.6, 0.7]),
    head=HeadControl(tilt=-0.1, pan=0.2)
)

# Access and modify the control
print(control.left_arm)  # Output: [0.1 0.2 0.3 0.4 0.5 0.6]
control.head.tilt = -0.2
print(control.head.tilt)  # Output: -0.2
</code></pre>
</details>

<details id="subclassing-motion">
<summary>Subclassing Motion</summary>
<p>You can create custom motion controls by subclassing the <code class ="back-text">Motion</code> class.</p>

<p><strong>Usage Example</strong></p>
<pre><code>from embdata.motion import Motion
from embdata.motion.fields import VelocityMotionField, AbsoluteMotionField

class CustomRobotControl(Motion):
    linear_velocity: float = VelocityMotionField(default=0.0, bounds=[-1.0, 1.0])
    angular_velocity: float = VelocityMotionField(default=0.0, bounds=[-1.0, 1.0])
    arm_position: float = AbsoluteMotionField(default=0.0, bounds=[0.0, 1.0])

# Create an instance of the custom control
custom_control = CustomRobotControl(
    linear_velocity=0.5,
    angular_velocity=-0.2,
    arm_position=0.7
)

print(custom_control)
# Output: CustomRobotControl(linear_velocity=0.5, angular_velocity=-0.2, arm_position=0.7)

# Validate bounds
try:
    invalid_control = CustomRobotControl(linear_velocity=1.5)  # This will raise a ValueError
except ValueError as e:
    print(f"Validation error: {e}")
</code></pre>
</details>

<details id="image">
<summary>Image</summary>
<p>The <code class ="back-text">Image</code> class represents image data and provides methods for manipulation and conversion.</p>

<p><strong>Key Features</strong></p>
<ul>
<li>Multiple representation formats (NumPy array, base64, file path, PIL Image, URL)</li>
<li>Easy conversion between different image formats</li>
<li>Resizing and encoding capabilities</li>
<li>Integration with other data processing pipelines</li>
</ul>

<p><strong>Usage Example</strong></p>
<pre><code>from embdata import Image
import numpy as np

# Create an Image from a numpy array
array_data = np.random.rand(100, 100, 3)
img = Image(array=array_data)

# Convert to base64
base64_str = img.base64

# Open an image from a file
img_from_file = Image.open("path/to/image.jpg")

# Resize the image
resized_img = Image(img_from_file, size=(50, 50))

# Save the image
img.save("output_image.png")

# Create an Image from a URL
img_from_url = Image("https://example.com/image.jpg")

# Create an Image from a base64 string
img_from_base64 = Image.from_base64(base64_str, encoding="png")
</code></pre>

<p><strong>Methods</strong></p>
<ul>
<li><code class ="back-text">open(path)</code>: Opens an image from a file path</li>
<li><code class ="back-text">save(path, encoding, quality)</code>: Saves the image to a file</li>
<li><code class ="back-text">show()</code>: Displays the image using matplotlib</li>
<li><code class ="back-text">from_base64(base64_str, encoding, size, make_rgb)</code>: Creates an Image instance from a base64 string</li>
<li><code class ="back-text">load_url(url, download)</code>: Downloads an image from a URL or decodes it from a base64 data URI</li>
<li><code class ="back-text">from_bytes(bytes_data, encoding, size)</code>: Creates an Image instance from a bytes object</li>
<li><code class ="back-text">space()</code>: Returns the space of the image</li>
<li><code class ="back-text">dump(*args, as_field, **kwargs)</code>: Returns a dict or a field of the image</li>
<li><code class ="back-text">infer_features_dict()</code>: Infers features of the image</li>
</ul>

<p><strong>Properties</strong></p>
<ul>
<li><code class ="back-text">array</code>: The image as a NumPy array</li>
<li><code class ="back-text">base64</code>: The image as a base64 encoded string</li>
<li><code class ="back-text">path</code>: The file path of the image</li>
<li><code class ="back-text">pil</code>: The image as a PIL Image object</li>
<li><code class ="back-text">url</code>: The URL of the image</li>
<li><code class ="back-text">size</code>: The size of the image as a (width, height) tuple</li>
<li><code class ="back-text">encoding</code>: The encoding format of the image</li>
</ul>

<p><strong>Class Methods</strong></p>
<ul>
<li><code class ="back-text">supports(arg)</code>: Checks if the argument is supported by the Image class</li>
<li><code class ="back-text">pil_to_data(image, encoding, size, make_rgb)</code>: Creates an Image instance from a PIL image</li>
<li><code class ="back-text">bytes_to_data(bytes_data, encoding, size, make_rgb)</code>: Creates an Image instance from a bytes object</li>
</ul>

<p>The <code class ="back-text">Image</code> class provides a convenient interface for working with image data in various formats and performing common image operations.</p>
</details>

<details id="trajectory">
<summary>Trajectory</summary>
<p>The <code class ="back-text">Trajectory</code> class represents a time series of multidimensional data, such as robot movements or sensor readings.</p>

<p><strong>Key Features</strong></p>
<ul>
<li>Representation of time series data with optional frequency information</li>
<li>Methods for statistical analysis, visualization, and manipulation</li>
<li>Support for resampling and filtering operations</li>
<li>Support for minmax, standard, and PCA transformations</li>
</ul>

<p><strong>Usage Example</strong></p>
<pre><code>from embdata import Trajectory
import numpy as np

# Create a Trajectory
data = np.random.rand(100, 3)  # 100 timesteps, 3 dimensions
traj = Trajectory(data, freq_hz=10)

# Compute statistics
stats = traj.stats()
print(stats)

# Plot the trajectory
traj.plot()

# Resample the trajectory
resampled_traj = traj.resample(target_hz=5)

# Apply a low-pass filter
filtered_traj = traj.low_pass_filter(cutoff_freq=2)

# Save the plot
traj.save("trajectory_plot.png")
</code></pre>

<p><strong>Methods</strong></p>
<ul>
<li><code class ="back-text">stats()</code>: Computes statistics for the trajectory</li>
<li><code class ="back-text">plot()</code>: Plots the trajectory</li>
<li><code class ="back-text">resample(target_hz)</code>: Resamples the trajectory to a new frequency</li>
<li><code class ="back-text">low_pass_filter(cutoff_freq)</code>: Applies a low-pass filter to the trajectory</li>
<li><code class ="back-text">save(filename)</code>: Saves the trajectory plot to a file</li>
<li><code class ="back-text">show()</code>: Displays the trajectory plot</li>
<li><code class ="back-text">transform(operation, **kwargs)</code>: Applies a transformation to the trajectory</li>
</ul>

<p>The <code class ="back-text">Trajectory</code> class offers methods for analyzing, visualizing, and manipulating trajectory data, making it easier to work with time series data in robotics and other applications.</p>
</details>

<details id="episode">
<summary>Episode</summary>
<p>The <code class ="back-text">Episode</code> class provides a list-like interface for a sequence of observations, actions, and other data, particularly useful for reinforcement learning scenarios.</p>

<p><strong>Key Features</strong></p>
<ul>
<li>List-like interface for managing sequences of data</li>
<li>Methods for appending, iterating, and splitting episodes</li>
<li>Support for metadata and frequency information</li>
<li>Integration with reinforcement learning workflows</li>
</ul>

<p><strong>Usage Example</strong></p>
<pre><code>from embdata import Episode, Sample

# Create an Episode
episode = Episode()

# Add steps to the episode
episode.append(Sample(observation=[1, 2, 3], action=0, reward=1))
episode.append(Sample(observation=[2, 3, 4], action=1, reward=0))
episode.append(Sample(observation=[3, 4, 5], action=0, reward=2))

# Iterate over the episode
for step in episode.iter():
    print(step.observation, step.action, step.reward)

# Split the episode based on a condition
def split_condition(step):
    return step.reward > 0

split_episodes = episode.split(split_condition)

# Extract a trajectory from the episode
action_trajectory = episode.trajectory(field="action", freq_hz=10)

# Visualize 3D geometrical data, images, and graphs with rerun.io
episode.show()

# Access episode metadata
print(episode.metadata)
print(episode.freq_hz)
</code></pre>

<p><strong>Methods</strong></p>
<ul>
<li><code class ="back-text">append(step)</code>: Adds a new step to the episode</li>
<li><code class ="back-text">iter()</code>: Returns an iterator over the steps in the episode</li>
<li><code class ="back-text">split(condition)</code>: Splits the episode based on a given condition</li>
<li><code class ="back-text">trajectory(field, freq_hz)</code>: Extracts a trajectory from the episode for a specified field</li>
<li><code class ="back-text">filter(condition)</code>: Filters the episode based on a given condition</li>
</ul>

<p><strong>Properties</strong></p>
<ul>
<li><code class ="back-text">metadata</code>: Additional metadata for the episode</li>
<li><code class ="back-text">freq_hz</code>: The frequency of the episode in Hz</li>
</ul>

<p>The <code class ="back-text">Episode</code> class simplifies the process of working with sequential data in reinforcement learning and other time-series applications.</p>
</details>

<details id="pose6d">
<summary>Pose6D</summary>
<p>The <code class ="back-text">Pose6D</code> class represents absolute coordinates for a 6D pose in 3D space, including position and orientation.</p>

<p><strong>Key Features</strong></p>
<ul>
<li>Representation of 3D pose with position (x, y) and orientation (theta)</li>
<li>Conversion between different units (meters, centimeters, radians, degrees)</li>
<li>Conversion to different formats (list, dict)</li>
</ul>

<p><strong>Usage Example</strong></p>
<pre><code>from embdata.geometry import Pose6D
import math

# Create a Pose3D instance
pose = Pose6D(x=1.0, y=2.0, z=3.0, roll=math.pi/10, pitch=math.pi/5, yaw=math.pi/3)

# Convert to different units
pose_cm = pose.to("cm")
print(pose_cm)  # Pose6D(x=100.0, y=200.0, z=300.0, roll=0.3141592653589793, pitch=0.6283185307179586, yaw=1.0471975511965976)

pose_deg = pose.to(angular_unit="deg")
print(pose_deg)  # Pose6D(x=1.0, y=2.0, z=3.0, roll=5.729577951308232, pitch=11.459155902616465, yaw=17.374763072956262)

# Convert to different formats
pose_list = pose.numpy()
print(pose_list)  # array([1.0, 2.0, 3.0, 0.1, 0.2, 0.3])

pose_dict = pose.dict()
print(pose_dict)  # {'x': 1.0, 'y': 2.0, 'z': 3.0, 'roll': 0.1, 'pitch': 0.2, 'yaw': 0.3}

pose.to("quaternion")
print(pose.quaternion())  # [0.9659258262890683, 0.0, 0.13052619222005157, 0.0]

pose.to("rotation_matrix")
print(pose.rotation_matrix())  # array([[ 0.8660254, -0.25, 0.4330127], [0.4330127, 0.75, -0.5], [-0.25, 0.61237244, 0.75]]
</code></pre>

<p><strong>Methods</strong></p>
<ul>
<li><code class ="back-text">to(container_or_unit, unit, angular_unit)</code>: Converts the pose to different units or formats</li>
</ul>

<p>The<code class ="back-text">Pose3D</code> class provides methods for converting between different units and representations of 3D poses, making it easier to work with spatial data in various contexts.</p>
</details>

<details id="handcontrol">
<summary>HandControl</summary>
<p>The <code class ="back-text">HandControl</code> class represents an action for a 7D space, including the pose of a robot hand and its grasp state.</p>

<p><strong>Key Features</strong></p>
<ul>
<li>Representation of robot hand pose and grasp state</li>
<li>Integration with other motion control classes</li>
<li>Support for complex nested structures</li>
</ul>

<p><strong>Usage Example</strong></p>
<pre><code>from embdata.geometry import Pose
from embdata.motion.control import HandControl

# Create a HandControl instance
hand_control = HandControl(
    pose=Pose(position=[0.1, 0.2, 0.3], orientation=[0, 0, 0, 1]),
    grasp=0.5
)

# Access and modify the hand control
print(hand_control.pose.position)  # [0.1, 0.2, 0.3]
hand_control.grasp = 0.8
print(hand_control.grasp)  # 0.8

# Example with complex nested structure
from embdata.motion import Motion
from embdata.motion.fields import VelocityMotionField

class RobotControl(Motion):
    hand: HandControl
    velocity: float = VelocityMotionField(default=0.0, bounds=[0.0, 1.0])

robot_control = RobotControl(
    hand=HandControl(
        pose=Pose(position=[0.1, 0.2, 0.3], orientation=[0, 0, 0, 1]),
        grasp=0.5
    ),
    velocity=0.3
)

print(robot_control.hand.pose.position)  # [0.1, 0.2, 0.3]
print(robot_control.velocity)  # 0.3
</code></pre>

<p><strong>Attributes</strong></p>
<ul>
<li><code class ="back-text">pose</code>: The pose of the robot hand (Pose object)</li>
<li><code class ="back-text">grasp</code>: The openness of the robot hand (float, 0 to 1)</li>
</ul>

<p>The <code class ="back-text">HandControl</code> class allows for easy manipulation and representation of robot hand controls in a 7D space, making it useful for robotics and motion control applications.</p>
</details>

<h2 id="license">License</h2>
<p><code>embdata</code> is distributed under the terms of the <a href="https://spdx.org/licenses/apache-2.0.html">apache-2.0</a> license.</p>
<h2 id="design-decisions">Design Decisions</h2>
<ul>
<li>Grasp value is [-1, 1] so that the default value is 0.</li>
<li>Motion rather than Action to distinguish from non-physical actions.</li>
<li>Flattened structures omit full paths to enable dataset transfer between different structures.</li>
</ul>
<h2 id="classes">Classes</h2>
<details>
<summary>Episode</summary>

<p>The <code>Episode</code> class provides a list-like interface for a sequence of observations, actions, and/or other data. It's designed to streamline exploratory data analysis and manipulation of time series data.</p>

<p><strong>Key features</strong></p>

<ul>
<li>List-like interface for managing sequences of data</li>
<li>Methods for appending, iterating, and splitting episodes</li>
<li>Support for metadata and frequency information</li>
<li>Integration with reinforcement learning workflows</li>
</ul>

<p><strong>Usage example</strong></p>

<pre><code>from embdata import Sample

from embdata import Episode, Sample

# Create an Episode
episode = Episode()

# Add steps to the episode
episode.append(Sample(observation=[1, 2, 3], action=0, reward=1))
episode.append(Sample(observation=[2, 3, 4], action=1, reward=0))
episode.append(Sample(observation=[3, 4, 5], action=0, reward=2))

# Iterate over the episode
for step in episode.iter():
    print(f"Observation: {step.observation}, Action: {step.action}, Reward: {step.reward}")

# Split the episode based on a condition
def split_condition(step):
    return step.reward > 0

split_episodes = episode.split(split_condition)

# Extract a trajectory from the episode
action_trajectory = episode.trajectory(field="action", freq_hz=10)

# Access episode metadata
print(episode.metadata)
print(episode.freq_hz)
</code></pre>

<p><strong>Methods</strong></p>

<ul>
<li><code>append(step)</code>: Adds a new step to the episode</li>
<li><code>iter()</code>: Returns an iterator over the steps in the episode</li>
<li><code>split(condition)</code>: Splits the episode based on a given condition</li>
<li><code>trajectory(field, freq_hz)</code>: Extracts a trajectory from the episode for a specified field</li>
<li><code>filter(condition)</code>: Filters the episode based on a given condition</li>
</ul>

<p><strong>Properties</strong></p>

<ul>
<li><code>metadata</code>: Additional metadata for the episode</li>
<li><code>freq_hz</code>: The frequency of the episode in Hz</li>
</ul>

<p>The <code>Episode</code> class simplifies the process of working with sequential data in reinforcement learning and other time-series applications.</p>

</details>

<details>
<summary>Image</summary>

<p>The <code>Image</code> class represents an image sample that can be represented in various formats, including NumPy arrays, base64 encoded strings, file paths, PIL Images, or URLs.</p>

<p><strong>Key Features</strong></p>

<ul>
<li>Multiple representation formats (NumPy array, base64, file path, PIL Image, URL)</li>
<li>Easy conversion between different image formats</li>
<li>Resizing and encoding capabilities</li>
<li>Integration with other data processing pipelines</li>
</ul>

<p><strong>Usage Example</strong></p>

<pre><code>from embdata import Image
import numpy as np

# Create an Image from a numpy array
array_data = np.random.rand(100, 100, 3)
img = Image(array=array_data)

# Convert to base64
base64_str = img.base64

# Open an image from a file
img_from_file = Image.open("path/to/image.jpg")

# Resize the image
resized_img = Image(img_from_file, size=(50, 50))

# Save the image
img.save("output_image.png")

# Create an Image from a base64 string
base64_str = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg=="
image = Image.from_base64(base64_str, encoding="png", size=(1, 1))
print(image.size)  # Output: (1, 1)

# Example with complex nested structure
nested_data = {
    "image": Image.from_base64(base64_str, encoding="png"),
    "metadata": {
        "text": "A small red square",
        "tags": ["red", "square", "small"]
    }
}
print(nested_data["image"].size)  # Output: (1, 1)
print(nested_data["metadata"]["text"])  # Output: A small red square
</code></pre>

<p><strong>Methods</strong></p>

<ul>
<li><code>open(path)</code>: Opens an image from a file path</li>
<li><code>save(path, encoding, quality)</code>: Saves the image to a file</li>
<li><code>show()</code>: Displays the image using matplotlib</li>
<li><code>from_base64(base64_str, encoding, size, make_rgb)</code>: Creates an Image instance from a base64 string</li>
</ul>

<p><strong>Properties</strong></p>

<ul>
<li><code>array</code>: The image as a NumPy array</li>
<li><code>base64</code>: The image as a base64 encoded string</li>
<li><code>path</code>: The file path of the image</li>
<li><code>pil</code>: The image as a PIL Image object</li>
<li><code>url</code>: The URL of the image</li>
<li><code>size</code>: The size of the image as a (width, height) tuple</li>
<li><code>encoding</code>: The encoding format of the image</li>
</ul>

<p>The <code>Image</code> class provides a convenient interface for working with image data in various formats and performing common image operations.</p>

</details>

<details>
<summary>Sample</summary>

<p>The <code>Sample</code> class is a base model for serializing, recording, and manipulating arbitrary data. It provides a flexible and extensible way to handle complex data structures, including nested objects, arrays, and various data types.</p>

<p><strong>Key Features</strong></p>

<ul>
<li>Serialization and deserialization of complex data structures</li>
<li>Flattening and unflattening of nested structures</li>
<li>Conversion between different formats (e.g., dict, numpy arrays, torch tensors)</li>
<li>Integration with machine learning frameworks and gym spaces</li>
</ul>

<p><strong>Usage Example</strong></p>

<pre><code>from embdata import Sample
import numpy as np

# Create a simple Sample instance
sample = Sample(x=1, y=2, z={"a": 3, "b": 4}, extra_field=5)

# Flatten the sample
flat_sample = sample.flatten()
print(flat_sample)  # Output: [1, 2, 3, 4, 5]

# Get the schema
schema = sample.schema()
print(schema)

# Unflatten a list back to a Sample instance
unflattened_sample = Sample.unflatten(flat_sample, schema)
print(unflattened_sample)  # Output: Sample(x=1, y=2, z={'a': 3, 'b': 4}, extra_field=5)

# Create a complex nested structure
nested_sample = Sample(
    image=Sample(
        data=np.random.rand(32, 32, 3),
        metadata={"format": "RGB", "size": (32, 32)}
    ),
    text=Sample(
        content="Hello, world!",
        tokens=["Hello", ",", "world", "!"],
        embeddings=np.random.rand(4, 128)
    ),
    labels=["greeting", "example"]
)

# Get the schema of the nested structure
nested_schema = nested_sample.schema()
print(nested_schema)
</code></pre>

<p><strong>Methods</strong></p>

<ul>
<li><code>flatten(output_type="list", non_numerical="allow", ignore=None, sep=".", to=None)</code>: Flattens the Sample instance into a one-dimensional structure</li>
<li><code>unflatten(one_d_array_or_dict, schema=None)</code>: Unflattens a one-dimensional array or dictionary into a Sample instance</li>
<li><code>to(container)</code>: Converts the Sample instance to a different container type</li>
<li><code>schema(include="simple")</code>: Get a simplified JSON schema of the data</li>
<li><code>space()</code>: Return the corresponding Gym space for the Sample instance</li>
<li><code>random_sample()</code>: Generate a random Sample instance based on its attributes</li>
</ul>

<p>The <code>Sample</code> class provides a wide range of functionality for data manipulation, conversion, and integration with various libraries and frameworks.</p>

</details>

<details>
<summary>Trajectory</summary>

<p>The <code>Trajectory</code> class represents a trajectory of steps, typically used for time series of multidimensional data such as robot movements or sensor readings.</p>

<p><strong>Key Features</strong></p>

<ul>
<li>Representation of time series data with optional frequency information</li>
<li>Methods for statistical analysis, visualization, and manipulation</li>
<li>Support for resampling and filtering operations</li>
<li>Transformation and normalization capabilities</li>
</ul>

<p><strong>Usage Example</strong></p>

<pre><code>import numpy as np
from embdata import Trajectory

# Create a simple 2D trajectory
steps = np.array([[0, 0], [1, 1], [2, 0], [3, 1], [4, 0]])
traj = Trajectory(steps, freq_hz=10, dim_labels=['X', 'Y'])

# Plot the trajectory
traj.plot().show()

# Compute and print statistics
print(traj.stats())

# Apply a low-pass filter
filtered_traj = traj.low_pass_filter(cutoff_freq=2)
filtered_traj.plot().show()

# Upsample with rotation splines and bicubic interpolation
upsampled_traj = traj.resample(target_hz=20)
print(upsampled_traj) # Output: Trajectory(steps=..., freq_hz=20, dim_labels=['X', 'Y'])

# Access data
print(traj.array)  # Output: [[0 0] [1 1] [2 0] [3 1] [4 0]]

# Get statistics
stats = traj.stats()
print(stats.mean)  # Output: [2. 0.4]
print(stats.std)   # Output: [1.41421356 0.48989795]

# Slice the trajectory
sliced_traj = traj[1:4]
print(sliced_traj.array)  # Output: [[1 1] [2 0] [3 1]]

# Transform the trajectory
normalized_traj = traj.transform('minmax')
normalized_traj.plot().show()
</code></pre>

<p><strong>Methods</strong></p>

<ul>
<li><code>plot()</code>: Plot the trajectory</li>
<li><code>stats()</code>: Compute statistics for the trajectory</li>
<li><code>low_pass_filter(cutoff_freq)</code>: Apply a low-pass filter to the trajectory</li>
<li><code>resample(target_hz)</code>: Resample the trajectory to a new frequency</li>
<li><code>make_relative()</code>: Convert the trajectory to relative actions</li>
<li><code>make_absolute(initial_state)</code>: Convert relative actions to absolute actions</li>
<li><code>frequencies()</code>: Plot the frequency spectrogram of the trajectory</li>
<li><code>frequencies_nd()</code>: Plot the n-dimensional frequency spectrogram of the trajectory</li>
<li><code>transform(operation, **kwargs)</code>: Apply a transformation to the trajectory</li>
<li><code>make_minmax(min, max)</code>: Apply min-max normalization</li>
<li><code>make_pca(whiten)</code>: Apply PCA transformation</li>
<li><code>make_standard()</code>: Apply standard normalization</li>
<li><code>make_unminmax(orig_min, orig_max)</code>: Reverse min-max normalization</li>
<li><code>make_unstandard(mean, std)</code>: Reverse standard normalization</li>
<li><code>q01(), q99()</code>: Get 1st and 99th percentiles</li>
<li><code>mean(), variance(), std(), skewness(), kurtosis()</code>: Statistical measures</li>
<li><code>min(), max()</code>: Minimum and maximum values</li>
<li><code>lower_quartile(), median(), upper_quartile()</code>: Quartile values</li>
<li><code>non_zero_count(), zero_count()</code>: Count non-zero and zero values</li>
</ul>

<p><strong>Properties</strong></p>

<ul>
<li><code>array</code>: The trajectory data as a NumPy array</li>
<li><code>freq_hz</code>: The frequency of the trajectory in Hz</li>
<li><code>time_idxs</code>: The time index of each step in the trajectory</li>
<li><code>dim_labels</code>: The labels for each dimension of the trajectory</li>
</ul>

<p>The <code>Trajectory</code> class offers comprehensive methods for analyzing, visualizing, manipulating, and transforming trajectory data, making it easier to work with time series data in robotics and other applications.</p>

</details>

<details>
<summary>Motion</summary>

<p>The <code>Motion</code> class is a base class for defining motion-related data structures. It extends the Coordinate class and provides a foundation for creating motion-specific data models.</p>

<p><strong>Key Features</strong></p>

<ul>
<li>Base class for motion-specific data models</li>
<li>Integration with MotionField and its variants for proper validation and type checking</li>
<li>Support for defining bounds and motion types</li>
</ul>

<p><strong>Usage Example</strong></p>

<pre><code>from embdata.motion import Motion
from embdata.motion.fields import VelocityMotionField

class Twist(Motion):
    x: float = VelocityMotionField(default=0.0, bounds=[-1.0, 1.0])
    y: float = VelocityMotionField(default=0.0, bounds=[-1.0, 1.0])
    z: float = VelocityMotionField(default=0.0, bounds=[-1.0, 1.0])
    roll: float = VelocityMotionField(default=0.0, bounds=["-pi", "pi"])
    pitch: float = VelocityMotionField(default=0.0, bounds=["-pi", "pi"])
    yaw: float = VelocityMotionField(default=0.0, bounds=["-pi", "pi"])

# Create a Twist motion
twist = Twist(x=0.5, y=-0.3, z=0.1, roll=0.2, pitch=-0.1, yaw=0.8)

print(twist)  # Output: Twist(x=0.5, y=-0.3, z=0.1, roll=0.2, pitch=-0.1, yaw=0.8)

# Access individual fields
print(twist.x)  # Output: 0.5

# Validate bounds
try:
    invalid_twist = Twist(x=1.5)  # This will raise a ValueError
except ValueError as e:
    print(f"Validation error: {e}")

# Example with complex nested structure
class RobotMotion(Motion):
    twist: Twist
    gripper: float = VelocityMotionField(default=0.0, bounds=[0.0, 1.0])

robot_motion = RobotMotion(
    twist=Twist(x=0.2, y=0.1, z=0.0, roll=0.0, pitch=0.0, yaw=0.1),
    gripper=0.5
)
print(robot_motion)
# Output: RobotMotion(twist=Twist(x=0.2, y=0.1, z=0.0, roll=0.0, pitch=0.0, yaw=0.1), gripper=0.5)
</code></pre>

<p><strong>Methods</strong></p>

<ul>
<li><code>validate_shape()</code>: Validates the shape of the motion data</li>
</ul>

<p><strong>Fields</strong></p>

<ul>
<li><code>MotionField</code>: Creates a field for a motion with specified properties</li>
<li><code>AbsoluteMotionField</code>: Field for an absolute motion</li>
<li><code>RelativeMotionField</code>: Field for a relative motion</li>
<li><code>VelocityMotionField</code>: Field for a velocity motion</li>
<li><code>TorqueMotionField</code>: Field for a torque motion</li>
<li><code>AnyMotionField</code>: Field for any other type of motion</li>
</ul>

<p><strong>Key Concepts</strong></p>

<ul>
<li>Subclasses of Motion should define their fields using MotionField or its variants (e.g., AbsoluteMotionField, VelocityMotionField) to ensure proper validation and type checking.</li>
<li>The Motion class does not allow extra fields and enforces validation of motion type, shape, and bounds.</li>
<li>It can handle various types of motion data, including nested structures with images and text, as long as they are properly defined using the appropriate MotionFields.</li>
</ul>

<p>The <code>Motion</code> class provides a flexible foundation for creating motion-specific data models with built-in validation and type checking, making it easier to work with complex motion data in robotics and other applications.</p>

</details>

<details>
<summary>AnyMotionControl</summary>

<p>The <code>AnyMotionControl</code> class is a subclass of Motion that allows for arbitrary fields with minimal validation. It's designed for motion control with flexible structure.</p>

<p><strong>Key Features</strong></p>

<ul>
<li>Allows arbitrary fields</li>
<li>Minimal validation compared to Motion</li>
<li>Includes optional names and joints fields</li>
</ul>

<p><strong>Usage Example</strong></p>

<pre><code>from embdata.motion import AnyMotionControl

# Create an AnyMotionControl instance
control = AnyMotionControl(names=["shoulder", "elbow", "wrist"], joints=[0.1, 0.2, 0.3])
print(control)  # Output: AnyMotionControl(names=['shoulder', 'elbow', 'wrist'], joints=[0.1, 0.2, 0.3])

# Add arbitrary fields
control.extra_field = "some value"
print(control.extra_field)  # Output: some value

# Validation example
try:
    invalid_control = AnyMotionControl(names=["joint1", "joint2"], joints=[0.1, 0.2, 0.3])
except ValueError as e:
    print(f"Validation error: {e}")
</code></pre>

<p><strong>Methods</strong></p>

<ul>
<li><code>validate_joints()</code>: Validates that the number of joints matches the number of names and that all joints are numbers</li>
</ul>

<p><strong>Fields</strong></p>

<ul>
<li><code>names</code>: Optional list of joint names</li>
<li><code>joints</code>: Optional list of joint values</li>
</ul>

<p>The <code>AnyMotionControl</code> class provides a flexible structure for motion control data with minimal constraints, allowing for easy integration with various robotic systems and control schemes.</p>

</details>

<details>
<summary>HandControl</summary>

<p>The <code>HandControl</code> class represents an action for a 7D space, including the pose of a robot hand and its grasp state.</p>

<p><strong>Key Features</strong></p>

<ul>
<li>Representation of robot hand pose and grasp state</li>
<li>Integration with other motion control classes</li>
<li>Support for complex nested structures</li>
</ul>

<p><strong>Usage Example</strong></p>

<pre><code>from embdata.geometry import Pose
from embdata.motion.control import HandControl

# Create a HandControl instance
hand_control = HandControl(
    pose=Pose(position=[0.1, 0.2, 0.3], orientation=[0, 0, 0, 1]),
    grasp=0.5
)

# Access and modify the hand control
print(hand_control.pose.position)  # Output: [0.1, 0.2, 0.3]
hand_control.grasp = 0.8
print(hand_control.grasp)  # Output: 0.8

# Example with complex nested structure
from embdata.motion import Motion
from embdata.motion.fields import VelocityMotionField

class RobotControl(Motion):
    hand: HandControl
    velocity: float = VelocityMotionField(default=0.0, bounds=[0.0, 1.0])

robot_control = RobotControl(
    hand=HandControl(
        pose=Pose(position=[0.1, 0.2, 0.3], orientation=[0, 0, 0, 1]),
        grasp=0.5
    ),
    velocity=0.3
)

print(robot_control.hand.pose.position)  # Output: [0.1, 0.2, 0.3]
print(robot_control.velocity)  # Output: 0.3
</code></pre>

<p><strong>Attributes</strong></p>

<ul>
<li><code>pose</code> (Pose): The pose of the robot hand, including position and orientation.</li>
<li><code>grasp</code> (float): The openness of the robot hand, ranging from 0 (closed) to 1 (open).</li>
</ul>

<p>The <code>HandControl</code> class allows for easy manipulation and representation of robot hand controls in a 7D space, making it useful for robotics and motion control applications. It can be integrated into more complex control structures and supports nested data representations.</p>

</details>

<details>
<summary>AbsoluteHandControl</summary>

<p>The <code>AbsoluteHandControl</code> class represents an action for a 7D space with absolute positioning, including the pose of a robot hand and its grasp state.</p>

<p><strong>Attributes</strong></p>

<ul>
<li><code>pose</code> (Pose): The absolute pose of the robot hand, including position and orientation.</li>
<li><code>grasp</code> (float): The openness of the robot hand, ranging from -1 (closed) to 1 (open).</li>
</ul>

<p>The <code>AbsoluteHandControl</code> class provides a straightforward way to define and manipulate absolute hand control actions in a 7D space, making it suitable for precise robotics applications and motion control tasks.</p>

</details>

<details>
<summary>RelativePoseHandControl</summary>

<p>The <code>RelativePoseHandControl</code> class represents an action for a 7D space with relative positioning for the pose and absolute positioning for the grasp.</p>

<p><strong>Attributes</strong></p>

<ul>
<li><code>pose</code> (Pose): The relative pose of the robot hand, including position and orientation.</li>
<li><code>grasp</code> (float): The openness of the robot hand, ranging from -1 (closed) to 1 (open).</li>
</ul>

<p>The <code>RelativePoseHandControl</code> class provides a flexible way to define and manipulate hand control actions with relative pose adjustments and absolute grasp states, making it suitable for various robotics applications and motion control tasks.</p>

</details>

<details>
<summary>HeadControl</summary>

<p>The <code>HeadControl</code> class represents the control for a robot's head movement.</p>

<p><strong>Attributes</strong></p>

<ul>
<li><code>tilt</code> (float): Tilt of the robot head in radians (down is negative).</li>
<li><code>pan</code> (float): Pan of the robot head in radians (left is negative).</li>
</ul>

<p>The <code>HeadControl</code> class provides a straightforward way to define and manipulate head movement controls for a robot, making it useful for various robotics applications and motion control tasks.</p>

</details>

<details>
<summary>MobileSingleHandControl</summary>

<p>The <code>MobileSingleHandControl</code> class represents control for a robot that can move its base in 2D space with a 6D EEF control and grasp.</p>

<p><strong>Attributes</strong></p>

<ul>
<li><code>base</code> (PlanarPose | None): Location of the robot on the ground.</li>
<li><code>hand</code> (HandControl | None): Control for the robot hand.</li>
<li><code>head</code> (HeadControl | None): Control for the robot head.</li>
</ul>

<p>The <code>MobileSingleHandControl</code> class provides a comprehensive way to control a mobile robot's base, hand, and head, making it suitable for complex robotics applications requiring coordinated movement and manipulation.</p>

</details>

<details>
<summary>MobileSingleArmControl</summary>

<p>The <code>MobileSingleArmControl</code> class represents control for a robot that can move in 2D space with a single arm.</p>

<p><strong>Attributes</strong></p>

<ul>
<li><code>base</code> (PlanarPose | None): Location of the robot on the ground.</li>
<li><code>arm</code> (NumpyArray | None): Control for the robot arm.</li>
<li><code>head</code> (HeadControl | None): Control for the robot head.</li>
</ul>

<p>The <code>MobileSingleArmControl</code> class provides a comprehensive way to control a mobile robot's base, arm, and head, making it suitable for complex robotics applications requiring coordinated movement and manipulation.</p>

</details>

<details>
<summary>MobileBimanualArmControl</summary>

<p>The <code>MobileBimanualArmControl</code> class represents control for a robot that can move in 2D space with two arms.</p>

<p><strong>Attributes</strong></p>

<ul>
<li><code>base</code> (PlanarPose | None): Location of the robot on the ground.</li>
<li><code>left_arm</code> (NumpyArray |>None): Control for the left robot arm.</li>
<li><code>right_arm</code> (NumpyArray | None): Control for the right robot arm.</li>
<li><code>head</code> (HeadControl | None): Control for the robot head.</li>
</ul>

<p>The <code>MobileBimanualArmControl</code> class provides a comprehensive way to control a mobile robot's base, left arm, right arm, and head, making it suitable for complex robotics applications requiring coordinated movement and manipulation with both arms.</p>

</details>

<details>
<summary>HumanoidControl</summary>

<p>The <code>HumanoidControl</code> class represents control for a humanoid robot.</p>

<p><strong>Attributes</strong></p>

<ul>
<li><code>left_arm</code> (NumpyArray | None): Control for the left robot arm.</li>
<li><code>right_arm</code> (NumpyArray | None): Control for the right robot arm.</li>
<li><code>left_leg</code> (NumpyArray | None): Control for the left robot leg.</li>
<li><code>right_leg</code> (NumpyArray</code> | None): Control for the right robot leg.</li>
<li><code>head</code> (HeadControl | None): Control for the robot head.</li>
</ul>

<p>The <code>HumanoidControl</code> class provides a comprehensive way to control a humanoid robot's arms, legs, and head, making it suitable for complex robotics applications requiring coordinated movement and manipulation.</p>

</details>

<h2 id="data-manupulation">Data Manupulation</h2>
<ul class="box-ul">
<li class="box-li"> 
<strong>Flattening:</strong> Flattening is the process of converting a nested data structure into a one-dimensional array or dictionary.
    <ul>
    <li>A dimension is with respect to a data structure of interest. For example, 1D can be a list of dictionaries where that dictionary structure represents a single dimension.
    </li>
    </ul>
    </li>
<li class="box-li"><strong> Nesting:</strong> Loosely defined as "structures not in the same list".</li> 
</ul>

<p>A nesting divides substructures by a boundary defined as "not sharing a list for an ancestor". For example, in a list of dictionaries, each dictionary is a separate nesting. All substructures within a dictionary are part of the same nesting so long as they are not part of different nestings in a list.</p>
<h2 id="rl-definitions">RL Definitions</h2>
<details>
<summary>Definitions Used by this Library</summary>

<ul class="box-ul">
<li class="box-li"><strong>Transition:</strong> A transition is a tuple (s, a, r, s') where s is the current state, a is the action taken, r is the reward received, and s' is the next state.</li>
  <li class="box-li"><strong>Episode:</strong> An episode is a sequence of transitions that starts at the initial state and ends at a terminal state.</li>
  <li class="box-li"><strong>Trajectory:</strong> A trajectory is a sequence of states, actions, and rewards that represents the behavior of an agent over time.</li>
  <li class="box-li"><strong>Policy:</strong> A policy is a mapping from states to actions that defines the behavior of an agent.</li>
  <li class="box-li"><strong>Value Function:</strong> A value function estimates the expected return from a given state or state-action pair under a given policy.</li>
  <li class="box-li"><strong>Q-Function:</strong> A Q-function estimates the expected return from a given state-action pair under a given policy.</li>
  <li class="box-li"><strong>Reward Function:</strong> A reward function defines the reward received by an agent for taking a particular action in a particular state.</li>
  <li class="box-li"><strong>Model:</strong> A model predicts the next state and reward given the current state and action.</li>
  <li class="box-li"><strong>Environment:</strong> An environment is the external system with which an agent interacts, providing states, actions, and rewards.</li>
  <li class="box-li"><strong>Agent:</strong> An agent is an entity that interacts with an environment to achieve a goal, typically by learning a policy or value function.</li>
  <li class="box-li"><strong>State:</strong> A state is a representation of the environment at a given point in time, typically including observations, measurements, or other data.</li>
  <li class="box-li"><strong>Exploration:</strong> Exploration is the process of selecting actions to gather information about the environment and improve the agent's policy or value function.</li>
<ul>

</details>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": ["content.code.annotate", "content.code.copy", "content.tabs.link", "navigation.expand", "announce.dismiss", "navigation.footer", "navigation.indexes", "navigation.sections", "navigation.top", "navigation.tracking", "search.highlight", "search.share", "search.suggest"], "search": "assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="javascripts/extra.js"></script>
      
    
  </body>
</html>